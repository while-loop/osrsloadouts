package store

import (
	"context"
	"github.com/while-loop/osrsloadouts/pkg/errors"
	"github.com/while-loop/osrsloadouts/pkg/utils"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"net/http"
	"time"
)

type User struct {
	Id       string    `json:"id" bson:"_id"`
	Username string    `json:"username" bson:"username"`
	Rsn      string    `json:"rsn" bson:"rsn"`
	Created  time.Time `json:"created" bson:"created"`
	Updated  time.Time `json:"updated" bson:"updated"`
}

func (u User) ToAuthor() Author {
	return Author{
		Id:       u.Id,
		Username: u.Username,
	}
}

var validUserKeys = []string{"username", "rsn", "updated"}

type UserStore interface {
	Get(ctx context.Context, id string) (*User, *errors.ApiError)
	GetByUsername(ctx context.Context, username string) (*User, *errors.ApiError)
	Delete(ctx context.Context, id string) *errors.ApiError
	Update(ctx context.Context, id string, props bson.M) (*User, *errors.ApiError)
	Create(ctx context.Context, user *User) (*User, *errors.ApiError)
}

type mongoUser struct {
	coll *mongo.Collection
}

const userColl = "users"

func NewUserStore(db *mongo.Database) UserStore {
	return &mongoUser{
		coll: db.Collection(userColl),
	}
}

func (m *mongoUser) Create(ctx context.Context, u *User) (*User, *errors.ApiError) {
	u.Created = time.Now().UTC()
	u.Updated = u.Created

	// dont set ID because ID is already generated by firebase
	id, err := Create(ctx, m.coll, u, false)
	if err != nil {
		return nil, err
	}

	u.Id = id
	return u, nil
}

func (m *mongoUser) Get(ctx context.Context, id string) (*User, *errors.ApiError) {
	return m.get(ctx, bson.D{{Key: "_id", Value: id}}, "id")
}

func (m *mongoUser) GetByUsername(ctx context.Context, username string) (*User, *errors.ApiError) {
	return m.get(ctx, bson.D{{Key: "username", Value: username}}, "username")
}

func (m *mongoUser) get(ctx context.Context, filter bson.D, id string) (*User, *errors.ApiError) {
	res := m.coll.FindOne(ctx, filter)
	if res.Err() != nil {
		return nil, errors.NewApif(http.StatusNotFound, res.Err(), "unable to find user %s", id)
	}

	u := new(User)
	err := res.Decode(u)
	if err != nil {
		return nil, errors.NewApif(http.StatusInternalServerError, err, "failed to decode user %s", id)
	}

	return u, nil
}

func (m *mongoUser) Delete(ctx context.Context, id string) *errors.ApiError {
	return Delete(ctx, m.coll, id)
}

func (m *mongoUser) Update(ctx context.Context, id string, props bson.M) (*User, *errors.ApiError) {
	props["updated"] = time.Now().UTC()

	props = utils.FilterM(props, validUserKeys)

	u := new(User)
	err := Update(ctx, m.coll, id, props, u)
	if err != nil {
		return nil, err
	}

	return u, nil
}
